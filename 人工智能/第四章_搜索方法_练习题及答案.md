# 第四章：搜索方法和启发式搜索 - 练习题

## 一、选择题（每题2分，共20分）

1. 在搜索问题中，状态空间通常包含：
   A. 起始状态、目标状态、操作符
   B. 节点、边、权重
   C. 数据、算法、结果
   D. 输入、输出、处理

2. 广度优先搜索算法的特点是：
   A. 最优但非完备
   B. 完备且最优（在单位代价情况下）
   C. 非完备非最优
   D. 完备但非最优

3. 启发式函数h(n)是可采纳（admissible）的条件是：
   A. h(n) ≥ h*(n)
   B. h(n) = h*(n)
   C. h(n) ≤ h*(n)
   D. h(n) = 0

4. A*算法的评估函数f(n)定义为：
   A. f(n) = g(n) - h(n)
   B. f(n) = g(n) + h(n)
   C. f(n) = h(n)
   D. f(n) = g(n)

5. 在A*搜索中，当启发函数满足一致性条件时，算法具有什么特性？
   A. 只能找到最优解
   B. 能保证找到最优解且效率较高
   C. 只能处理小规模问题
   D. 不需要存储节点

6. 以下哪种搜索算法属于有信息搜索（启发式搜索）？
   A. 深度优先搜索
   B. 广度优先搜索
   C. A*搜索
   D. 一致代价搜索

7. 迭代加深搜索（IDS）的主要优势是：
   A. 空间复杂度低，完备且最优
   B. 时间复杂度最低
   C. 适合无限状态空间
   D. 不需要启发函数

8. 在博弈树搜索中，极小化极大算法的基本思想是：
   A. 最大化所有可能结果
   B. 最小化所有可能结果
   C. MAX选择最大值，MIN选择最小值
   D. 随机选择结果

9. α-β剪枝技术的主要作用是：
   A. 提高搜索完备性
   B. 改善搜索效率，不改变最终结果
   C. 保证解的最优性
   D. 减少内存使用

10. 以下哪个不是搜索问题的组成部分？
    A. 状态空间
    B. 后继函数
    C. 目标测试
    D. 存储设备

## 二、填空题（每空2分，共20分）

1. 搜索问题的五个基本要素是________、________、________、________和________。

2. 搜索算法的性能度量标准包括________、________、________和________。

3. A*算法保证最优解的条件是启发函数________且________。

4. 在博弈搜索中，MIN节点的值等于其所有后继节点值的________，MAX节点的值等于其所有后继节点值的________。

5. 深度优先搜索的时间复杂度是________，空间复杂度是________（b为分支因子，m为最大深度）。

6. 启发式搜索与无信息搜索的主要区别在于是否使用________信息。

## 三、计算题（每题10分，共30分）

1. 给定状态空间图，节点S到目标G，边及代价如下：S→A(1)，S→B(4)，A→C(2)，B→C(1)，C→G(3)。启发函数值：h(S)=7，h(A)=4，h(C)=2，h(B)=5，h(G)=0。使用A*算法求解从S到G的路径。

2. 考虑一个简单的博弈树，根节点为MAX，有3个子节点（MIN节点），每个MIN节点有2个叶子节点（效用值分别为：[3,5], [1,2], [4,6]）。画出博弈树并用极小化极大算法求解根节点的值。

3. 对于一个搜索问题，如果分支因子b=3，最大深度m=5，求广度优先搜索和深度优先搜索的时空复杂度，并比较它们的优缺点。

## 四、简答题（每题10分，共20分）

1. 比较广度优先搜索、深度优先搜索和A*搜索的优缺点及适用场景。

2. 解释启发式函数的一致性（consistency）条件，并说明其与可采纳性（admissibility）的关系。

## 五、应用题（每题10分，共10分）

1. 设计一个基于A*算法的路径规划系统，用于在网格地图上寻找最短路径。请详细说明：节点表示、启发函数设计、算法实现要点、以及如何处理动态障碍物。

---
# 第四章：搜索方法和启发式搜索 - 详细答案

## 一、选择题答案

1. **答案：A**
   详解：搜索问题的三要素是起始状态、目标状态和操作符（行动）。

2. **答案：B**
   详解：BFS在单位代价情况下既完备（能找到解）又最优（找到最浅解）。

3. **答案：C**
   详解：可采纳性要求启发函数不高于实际代价，即h(n) ≤ h*(n)。

4. **答案：B**
   详解：A*算法的评估函数f(n) = g(n) + h(n)，其中g(n)是实际代价，h(n)是启发代价。

5. **答案：B**
   详解：一致性启发函数使A*具有最优效率，既保证最优解又提高搜索效率。

6. **答案：C**
   详解：A*使用启发函数，属于有信息搜索；其他都是无信息搜索。

7. **答案：A**
   详解：IDS具有线性空间复杂度，同时保持完备性和最优性。

8. **答案：C**
   详解：极小化极大算法中MAX选择最大值，MIN选择最小值。

9. **答案：B**
   详解：α-β剪枝在不影响结果的前提下跳过部分搜索，提高效率。

10. **答案：D**
    详解：搜索问题的四个组成部分是状态空间、后继函数、目标测试和路径代价。

## 二、填空题答案

1. **答案：** 状态空间、后继函数、目标测试、路径代价、搜索策略
    详解：搜索问题的基本要素。

2. **答案：** 时间复杂度、空间复杂度、完备性、最优性
    详解：搜索算法的主要评价标准。

3. **答案：** 可采纳（admissible）、一致性（consistent）
    详解：A*最优的两个条件。

4. **答案：** 最小值、最大值
    详解：极小化极大算法的值传递规则。

5. **答案：** O(b^m)、O(bm)
    详解：DFS的时空复杂度。

6. **答案：** 问题特定的启发式
    详解：启发式搜索利用问题特定知识。

## 三、计算题答案

### 1. A*算法求解路径

**答案：**
A*算法使用f(n) = g(n) + h(n)，逐步扩展节点：

初始化：OPEN=[S(0+7=7)], CLOSED=[]
- 从S开始，扩展S→A(1+4=5), S→B(4+5=9)，OPEN=[A(5), B(9)], CLOSED=[S]
- 选择A，扩展A→C(1+2+2=5)，OPEN=[C(5), B(9)], CLOSED=[S, A]
- 选择C，扩展C→G(1+2+3+0=6)，OPEN=[G(6), B(9)], CLOSED=[S, A, C]
- 选择G，到达目标

**路径：** S→A→C→G，总代价6

**详解：** A*算法按照f(n)值从小到大扩展节点，保证找到最优解。

### 2. 极小化极大算法求解

**答案：**
博弈树结构：
```
        MAX(根)
       /   |   \
     MIN  MIN  MIN
    / \   / \   / \
   3   5 1   2 4   6
```

计算过程：
- 左MIN节点：min(3,5) = 3
- 中MIN节点：min(1,2) = 1  
- 右MIN节点：min(4,6) = 4
- 根节点MAX：max(3,1,4) = 4

**答案：** 根节点值为4

**详解：** 从叶子节点向上计算，MIN节点取最小值，MAX节点取最大值。

### 3. BFS与DFS复杂度比较

**答案：**
给定b=3, m=5：

**广度优先搜索：**
- 时间复杂度：O(b^d) = O(3^5) = O(243)（设目标深度为5）
- 空间复杂度：O(b^d) = O(243)

**深度优先搜索：**
- 时间复杂度：O(b^m) = O(3^5) = O(243)
- 空间复杂度：O(bm) = O(3×5) = O(15)

**比较：**
BFS优点：完备且最优；缺点：空间需求大。
DFS优点：空间效率高；缺点：非最优，非完备（无限深度时）。

**详解：** BFS需要存储所有层的节点，空间开销大；DFS只需存储当前路径，空间效率高。

## 四、简答题答案

### 1. 比较三种搜索算法的优缺点及适用场景

**广度优先搜索（BFS）：**
- 优点：完备（有限状态空间中总能找到解）、最优（单位代价时）
- 缺点：空间复杂度高O(b^d)
- 适用场景：解较浅、空间资源充分、要求最优解

**深度优先搜索（DFS）：**
- 优点：空间复杂度低O(bm)、时间复杂度O(b^m)
- 缺点：非最优、非完备（无限深度时）
- 适用场景：解较深、空间受限、不要求最优

**A*搜索：**
- 优点：完备、最优（当启发函数可采纳时）、效率高（使用好的启发函数）
- 缺点：需要良好启发函数、空间复杂度可能高
- 适用场景：有良好启发信息、要求最优解、路径规划

**详解：** A*是最实用的算法，兼顾效率和最优性，但需要设计合适的启发函数。

### 2. 启发函数一致性与可采纳性的关系

**一致性（Consistency）条件：**
对于任意节点n和其后继节点n'，以及从n到n'的代价c(n,n')，启发函数h(n)应满足：
h(n) ≤ c(n,n') + h(n')

**几何解释：** 启发函数满足三角不等式，构成启发代价的"度量空间"。

**与可采纳性关系：**
1. 一致性 ⇒ 可采纳性：如果启发函数一致，则必然可采纳
   - 证明：从n到目标的启发值 ≤ n到n'的真实代价 + n'到目标的启发值
   - 沿最优路径推导：h(n) ≤ h*(n)（实际最优代价）

2. 可采纳性 ↛ 一致性：可采纳的启发函数不一定一致
   - 反例：某些启发函数可采纳但不满足三角不等式

**实际意义：**
- 可采纳性：保证A*找到最优解
- 一致性：除保证最优性外，还保证A*对每个节点只扩展一次，提高效率

**详解：** 一致性是比可采纳性更强的条件，实际应用中应尽量设计一致的启发函数。

## 五、应用题答案

### 1. A*路径规划系统设计

**节点表示：**
```
class Node:
    def __init__(self, x, y, cost=0, heuristic=0):
        self.x = x  # 栅格行号
        self.y = y  # 栅格列号
        self.g = cost  # 从起点到当前点的实际代价
        self.h = heuristic  # 启发函数值
        self.f = cost + heuristic  # 评估函数值
        self.parent = None  # 父节点，用于回溯路径
```

**启发函数设计：**
- **曼哈顿距离：** h(n) = |x1-x2| + |y1-y2|（仅允许4方向移动）
- **欧几里得距离：** h(n) = √((x1-x2)² + (y1-y2)²)（允许8方向移动）
- **对角距离：** h(n) = D×(dx+dy) + (D2-2×D)×min(dx,dy)（其中D=1，D2=√2）

**算法实现要点：**
```python
def a_star(start, goal, grid):
    open_list = PriorityQueue()  # 优先队列
    closed_list = set()  # 已访问节点集合
    
    start_node = Node(start[0], start[1])
    open_list.put((start_node.f, start_node))
    
    while not open_list.empty():
        current = open_list.get()[1]
        closed_list.add((current.x, current.y))
        
        if (current.x, current.y) == goal:
            return reconstruct_path(current)  # 找到目标，重构路径
        
        # 探索后继节点
        for neighbor in get_neighbors(current, grid):
            if (neighbor.x, neighbor.y) in closed_list:
                continue
                
            tentative_g = current.g + get_distance(current, neighbor)
            
            if neighbor not in open_list or tentative_g < neighbor.g:
                neighbor.parent = current
                neighbor.g = tentative_g
                neighbor.h = heuristic(neighbor, goal)
                neighbor.f = neighbor.g + neighbor.h
                
                open_list.put((neighbor.f, neighbor))
    
    return None  # 未找到路径
```

**动态障碍物处理：**
1. **重规划机制：** 检测到路径上有新障碍物时，重新运行A*
2. **局部修复：** 对小范围动态障碍采用局部路径修复
3. **势场方法：** 结合人工势场处理动态障碍
4. **预测机制：** 预测动态障碍物运动轨迹

**详解：** A*路径规划系统需要在效率和最优性之间权衡，同时考虑动态环境的处理策略。